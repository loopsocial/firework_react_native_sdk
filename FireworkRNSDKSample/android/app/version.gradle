import java.util.regex.Pattern

ext {
  commitId = "git rev-parse --short=5 HEAD".execute([], rootDir).text.trim()
  commitTime = "git log HEAD -1 --pretty=%cd --date=iso".execute([], rootDir).text.trim()
  gitBranchName = getGitBranchName()
  tagPrefix = "android-"
}

android {

  applicationVariants.all { variant ->
    if (variant.name == 'debug') {
      variant.outputs.each { output ->
        println "============debug version generating============"
        // print old version name
        def baseVersionName = output.versionNameOverride
        println "old version name:\t${baseVersionName}"
        // print base version code
        def names = output.versionNameOverride.replaceAll("\\s*\\(.*\\)", "").split("\\.")
        def baseVersionCode = names[0].toInteger() * 100000 + names[1].toInteger() * 1000 + names[2].toInteger() * 100
        println "base version code:\t${baseVersionCode}"
        // print base version commit id
        def baseCommitId = "HEAD"
        def logs = ["git", "log", "--abbrev-commit", "-S", "versionCode $baseVersionCode", "-p", "${project.file("build.gradle").canonicalPath}"]
          .execute([], rootDir).text.trim().split("\n")
        def commitReg = Pattern.compile("commit\\s+([0-9a-fA-F]+).*")
        for (int i = logs.size() - 1; i >= 0; i--) {
          if (logs[i].matches(commitReg)) {
            baseCommitId = logs[i].replaceFirst(commitReg, "\$1")
            break
          }
        }
        println "base version id:\t$baseCommitId"
        // print commit count for base commit id
        def baseCommitCount = "git rev-list $baseCommitId --count".execute([], rootDir).text.trim()
        println "base commit count:\t$baseCommitCount"
        // print commit count for current HEAD
        def headCommitCount = "git rev-list HEAD --count".execute([], rootDir).text.trim()
        println "head commit count:\t$headCommitCount"
        // print new version code
        def versionCode = baseVersionCode + headCommitCount.toInteger() - baseCommitCount.toInteger()
        // set maxCode = next release code - 1
        def maxCode = names[0].toInteger() * 100000 + names[1].toInteger() * 1000 + 999
        if (versionCode > maxCode) {
          versionCode = maxCode
        }
        println "version code:\t\t$versionCode"
        // print new version name
//        def time = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss z").parse("$commitTime")
//        def versionName = "${baseVersionName} ${new SimpleDateFormat("MM-dd HH:mm:ss").format(time)}"
        def versionName = "${baseVersionName}${getTagSign()}"
        println "version name:\t\t$versionName"
        // define version code and version name
        output.versionCodeOverride = versionCode
        output.versionNameOverride = versionName
        println "============debug version generated============"
      }
    } else if (variant.name == 'release') {
      variant.outputs.each { output ->
        println "============release version checking============"
        // print version code and version name
        println "version code:\t\t${output.versionCodeOverride}"
        println "version name:\t\t${output.versionNameOverride}"
        // print version tag
        def names = output.versionNameOverride.replaceAll("\\s*\\(.*\\)", "").split("\\.")
        def baseVersion = "${tagPrefix}${names[0]}.${names[1]}.${names[2]}"
        println "base version tag:\t$baseVersion"
        // check if version tag is added
        def baseCommitCount = "git rev-list $baseVersion --count".execute([], rootDir).text.trim()
        if (baseCommitCount == "") {
          System.err.println "version tag missing: git tag $baseVersion;git push origin $baseVersion"
        }
        // check if version code is right
        def minCode = names[0].toInteger() * 100000 + names[1].toInteger() * 1000 + names[2].toInteger() * 100
        def code = output.versionCodeOverride.toInteger()
        if (code < minCode || code > minCode + 99) {
          def msg = "Version code isn't match version name, it should be in [$minCode...${minCode+99}]!"
          System.err.println msg
          throw new IllegalAccessException(msg)
        }
        println "============release version checked============"
      }
    }
  }
}

def getGitBranchName() {
  if (project.hasProperty('PACKAGING_BRANCH'))
    return PACKAGING_BRANCH.toString().trim()
  else
    return "git name-rev --name-only HEAD".execute([], rootDir).text
      .trim().replaceFirst(Pattern.compile(".*/"), "")
}

def getTagSign() {
  switch (gitBranchName) {
    case "main":
      return ""
    case "develop":
      return "-test"
    default:
      return "-${gitBranchName}"
  }
}

def createReleaseNotes(variantName, versionName, versionCode) {
  project.file("build/${project.name}-releasenotes-${variantName}.txt")
    .write("$gitBranchName - $commitTime\n" +
      "${project.name}($versionName, $versionCode)\n" +
      "${System.getenv("BUILD_TAG")}\n"
    )
  project.file("build/${project.name}-releasenotes-${variantName}.html")
    .write("<script>\n" +
      "location.href = \"\"\n" +
      "</script>")
  return "create release note: ${variantName}-${versionName}-${versionCode}"
}

static def isVersionCodeChanged(project) {
  def file = project.file("build.gradle").canonicalPath
  def buildChangeList = "git diff HEAD~1 HEAD \"$file\"".execute([], project.rootDir).text.trim().split("[\r\n]+")
  def versionOld = ""
  def versionNew = ""
  for (line in buildChangeList) {
    println line
    if (line.matches("\\s*-\\s*versionCode\\s*(\\d+)\\s*")) {
      versionOld = line.replaceAll("\\s*-\\s*versionCode\\s*(\\d+)\\s*", "\$1")
    } else if (line.matches("\\s*\\+\\s*versionCode\\s*(\\d+)\\s*")) {
      versionNew = line.replaceAll("\\s*\\+\\s*versionCode\\s*(\\d+)\\s*", "\$1")
    }
  }
  if (versionOld != versionNew) {
    println "The version code of $project.name is changed from $versionOld to $versionNew"
  } else {
    println "The version code of $project.name isn't changed."
  }
//  return versionOld != versionNew
  return true
}

afterEvaluate {
  try {
    preBuild.dependsOn libReportReleaseRuntimeClasspath
  } catch (Exception e) {
    e.printStackTrace()
  }
  try {
    android.applicationVariants.all { variant ->
      def upVariantName = variant.name.substring(0, 1).toUpperCase() + variant.name.substring(1)
      project.task("createReleaseNotes$upVariantName") {
        doLast {
          variant.outputs.each { output ->
            println createReleaseNotes(variant.name, output.versionNameOverride, output.versionCodeOverride)
          }
        }
      }
      project.getTasksByName("assemble$upVariantName", false).find()
        .dependsOn(project.getTasksByName("createReleaseNotes$upVariantName", false).find())
    }
  } catch (Exception e) {
    e.printStackTrace()
  }
  if (isVersionCodeChanged(project)) {
    try {
      assembleReleaseIfCodeChanged.dependsOn assembleRelease
    } catch (Exception e) {
      e.printStackTrace()
    }
  }
}

task assembleReleaseIfCodeChanged()

task checkVersionCodeChanged {
  doLast {
    if (project.name == "app") {
      // only run in root project
      def changed = false
      for (subProject in rootProject.allprojects) {
        if (!subProject.getTasksByName("checkVersionCodeChanged", false).isEmpty()) {
          changed |= isVersionCodeChanged(subProject)
        }
      }
      if (!changed) {
        throw new IllegalAccessException("The version code must be changed in the last commit!")
      }
    }
  }
}

task addTag {
  doLast {
    try {
      // todo://
    } catch (Exception e) {
      e.printStackTrace()
    }
  }
}

